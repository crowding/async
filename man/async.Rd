% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pump.R, R/async.R
\name{with_prefix}
\alias{with_prefix}
\alias{async}
\alias{await}
\title{Create an asynchronous task from sequential code.}
\usage{
with_prefix(prefix)

async(
  expr,
  ...,
  split_pipes = TRUE,
  trace = trace_,
  compileLevel = getOption("async.compileLevel")
)

await(prom)
}
\arguments{
\item{prefix}{A function to print debugging messages. \code{trace=cat}
will log async actions to the console; \code{trace=with_prefix("myPrefix")}
adds a prefix if you have more than one async to debug.}

\item{expr}{An expression, to be executed asynchronously.}

\item{...}{Undocumented.}

\item{split_pipes}{Rewrite chained calls that use \code{await}
(see below)}

\item{trace}{Enable verbose logging by passing a function to
\code{trace}, like \code{async(trace=cat, {...})}. \code{trace} should take a
character argument. Helper \code{with_prefix} makes a function that
prints a message with the given prefix. You can also say something
like \code{trace=browser} for "single stepping" through an async.}

\item{compileLevel}{Compilation level; same options as for \link{gen}.}

\item{prom}{A promise, or something that can be converted to such
by \code{\link[promises:is.promise]{promises::as.promise()}}.}
}
\value{
\code{async()} returns an object with class "promise," as
defined by the \link{promises} package (i.e., rather than the kind of
promise used in R's lazy evaluation.)

In the context of an \code{async}, \code{await(x)} returns the
resolved value of a promise \code{x}, or stops with an error.
}
\description{
\code{async({...})}, with an expression written in its argument, allows
that expression to be evaluated in an asynchronous, or non-blocking
manner. \code{async} returns an object with class \code{c("async", "promise")} which
implements the \link[promises:promise]{promise} interface.
}
\details{
An example Shiny app using \code{async/await} is on Github:
\url{https://github.com/crowding/cranwhales-await}

When an \code{async} object is activated, it will evaluate its expression
until it reaches the keyword \code{await}. The \code{async} object will return
to its caller and preserve the partial state of its evaluation.
When the awaited promise is resolved, evaluation continues from where
the \code{async} left off.

When an async block finishes (either by reaching the end, or using
\code{return()}), the promise resolves with the resulting value. If the
async block stops with an error, the promise is rejected with
that error.

Async blocks and generators are conceptually related and share much
of the same underlying mechanism. You can think of one as "output"
and the other as "input". A generator pauses until a value is
requested, runs until it has a value to output, then pauses again.
An async runs until it requires an external value, pauses until
it receives the value, then continues.

The syntax rules for an \code{async} are analogous to those for \code{\link[=gen]{gen()}};
\code{await} must appear only within the arguments of functions for
which there is a pausable implementation (See \verb{[pausables()]}). For
\code{async} the default \code{split_pipes=TRUE} is enabled; this will
rearrange some expressions to satisfy this requirement.

When \code{split_pipes=FALSE}, \code{await()} can only appear in the
arguments of \link{pausables} and not ordinary R functions.  This is an
inconvenience as it prevents using \code{await()} in a pipeline. With
\code{split_pipes=TRUE} applies some syntactic sugar: if an \code{await()}
appears in the leftmost, unnamed, argument of an R function, the
pipe will be "split" at that call using a temporary variable. For
instance, either

\if{html}{\out{<div class="sourceCode">}}\preformatted{async(makeRequest() |> await() |> sort())
}\if{html}{\out{</div>}}

or, equivalently,

\if{html}{\out{<div class="sourceCode">}}\preformatted{async(sort(await(makeRequest())))
}\if{html}{\out{</div>}}

will be effectively rewritten to something like

\if{html}{\out{<div class="sourceCode">}}\preformatted{async(\{.tmp <- await(makeRequest()); sort(.tmp)\})
}\if{html}{\out{</div>}}

This works only so long as \code{await} appears in calls that evaluate
their leftmost arguments normally. \code{split_pipes} can backfire if
the outer call has other side effects; for instance
\code{suppressWarnings(await(x))} will be rewritten as \code{{.tmp <- await(x); suppressWarnings(x)}}, which would defeat the purpose.

If \code{async} is given a function expression, like \code{async(function(...) ...)}, it will return an "async function" i.e. a function that
constructs an async.
}
\examples{
myAsync <- async(for (i in 1:4) {
  await(delay(5))
  cat(i, "\n")
}, trace=with_prefix("myAsync"))

}
