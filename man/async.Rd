% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/async.r, R/pump.r
\name{async}
\alias{async}
\alias{await}
\alias{with_prefix}
\title{Create an asynchronous task from sequential code.}
\usage{
async(expr, ..., split_pipes = TRUE)

await(prom)

with_prefix(prefix)
}
\arguments{
\item{expr}{An expression, to be executed asynchronously.}

\item{split_pipes}{Silently rewrite chained calls that use `await` (see below)}

\item{prom}{A promise, or something that can be converted to such
by [promises::as.promise()].}

\item{trace}{Enable verbose logging by passing a function to
`trace`, as in `async(trace=cat, {...})`. `trace` needs to take a
character argument. `trace` should take a character argument.
`async(trace=with_prefix("myAsync"), {...})` will trace the async
to console with the given prefix.  For debugging, you can also do
things like `trace=browser` for "single stepping" through an
async.}
}
\value{
`async` constructs and returns a [promises::promise]
  object.

In the context of an `async`, `await` returns the resolved of
  a promise, or stops with an error.
}
\description{
`async({...})`, with an expression written in its argument, allows
that expression to be evaluated in an asynchronous, or non-blocking
manner. `async` returns an object with class `c("async", "promise")` which
implements the [promises::promise] interface.
}
\details{
When an `async` object is activated, it will evaluate its expression
until it reaches the keyword `await`. The delay object will return
to its caller and preserve the partial state of its evaluation.
When the awaited value is resolved, evaluation continues from where
the `async` left off.

When an async block finishes (either by reaching the end, or using
`return()`), the promise resolves with the resulting value. If the
async block stops with an error, the promise is rejected with
that error.

The syntax rules for an `async` are analogous to those for [gen()];
`await` must appear only within the arguments of functions for
which there is a pausable implementation (See `?[pausable]`). By
default `split_pipes` is enabled and this will reorder some
expressions to satisfy this requirement.

Async blocks and generators are conceptually related and share much
of the same underlying mechanism. You can think of one as "output"
and the other as "input". A generator pauses until a value is
requested, runs until it has a value to output, then pauses again.
An async runs until it requires an external value, pauses until
it receives the value, then continues.

When `split_pipes=FALSE`, `await()` can only appear in the
arguments of [pausable] functions and not ordinary R functions.
This is a inconvenience as it prevents using `await()` in a
pipeline. `async` by default has `split_pipes=TRUE` which enables
some syntactic sugar: if an `await()` appears in the leftmost,
unnamed, argument of an R function, the pipe will be "split" at
that call using a temporary variable. For instance `sort(await(x))`
will be silently rewritten as `{..async.tmp <- await(x);
sort(..async.tmp)}`. This works only so long as `await` appears in
calls that evaluate their leftmost arguments
normally. `split_pipes` can backfire if the outer call has other
side effects; for instance `suppressWarnings(await(x))` will be
rewritten as `{.tmp <- await(x); suppressWarnings(x)}`, which
defeats the purpose.
}
