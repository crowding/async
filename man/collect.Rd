% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/collect.R
\name{collect}
\alias{collect}
\alias{collector}
\title{Execute a function and collect a set of values by callback.}
\usage{
collect(fn, type = list())

collector(fn, type = list())
}
\arguments{
\item{fn}{A function, which should accept a single argument, here
called \code{emit}.}

\item{type}{A prototype output vector (i.e. a vector of the same
type as the desired output, similar to \code{FUN.VALUE} of \link{vapply}.)
Defaults to \code{list()}.}
}
\value{
A vector of all values passed to \code{emit} whle \code{fn} was
running.
}
\description{
\code{collect} calls the function \code{fn} in its argument, supplying a
callback of the form \code{function (val, name=NULL).} I like to call it
\code{emit}.  While \code{fn} is running, it can call \code{emit(x)} any number of
times.  After \code{fn} returns, all the values passed to \code{emit} are
returned in a vector, with optional names.

\code{collector()} works similarly but does not gather
values when your inner function returns. Instead, it provides
your inner function with two callbacks, one to add a value and
the second to extract the value; so you can use that callback to
extract values at a later time. For an example of \code{collector}
usage see the definition of \link{gather}.
}
\examples{

#cumulative sum
cumsum <- function(vec) {
  total <- 0
  collect(type=0, function(emit) {
    for (i in vec) total <- emit(total+i)
  })
}

# we could implement `iterors::as.list.iteror` thus:
as.list.iteror <- function(it) {
  collect(\(yield) repeat yield(nextOr(it, break)))
}
}
\author{
Peter Meilstrup
}
