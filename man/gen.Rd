% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/syntax.r
\name{yield}
\alias{yield}
\alias{gen}
\title{Create an iterator using sequential code.}
\usage{
yield(expr)

gen(expr, ...)
}
\description{
`gen({...})` with an expression written in its argument, creates a
generator, which can be thought of as a block of code whose
execution can pause and resume. From the inside, a generator looks
like you are writing sequential code with loops, branches and such,
writing values to the outside world by calling `yield()`. From the
outside, a generator behaves like an iterator over
an indefinite collection.
}
\details{
Generators are not based on forking or parallel OS processes; they
run in the same thread as their caller. The control flow in a
generator is interleaved with that of the R code which queries it.

When `nextItem` is called on a generator, the generator evaluates
its given expression until it reaches a call to `yield(...).` The
value passed to `yield` is returned. The generator's execution
state is preserved and will continue form where ti left off on the
next call to `nextItem.`

There are some syntactic restrictions on what you can write in a
generator expression. `yield` must appear only directly within
control flow operators. Wherever `yield` appears in a generator
expression, the calls it is nested within must have CPS
implementations. (This package provides CPS implementations for
several base R control flow builtins; the list is in the
non-exported variable `generators:::cps_builtins`).
}
