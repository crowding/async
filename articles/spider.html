<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Scraping the web quickly using async/await • async</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Scraping the web quickly using async/await">
<meta property="og:description" content="async">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    

    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">async</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">0.3.2</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/README.html">The `async` package: Generators, async/await, and asynchronous streams for R</a>
    </li>
    <li>
      <a href="../articles/clapping.html">A Musical Introduction to Generators</a>
    </li>
    <li>
      <a href="../articles/language.html">The Coroutine Language</a>
    </li>
    <li>
      <a href="../articles/spider.html">Scraping the web quickly using async/await</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/crowding/async/" class="external-link">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Scraping the web quickly using async/await</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/crowding/async/blob/HEAD/vignettes/spider.Rmd" class="external-link"><code>vignettes/spider.Rmd</code></a></small>
      <div class="hidden name"><code>spider.Rmd</code></div>

    </div>

    
    
<p>A common data science task is extracting data from a website. Many
public-facing websites do not have a public facing API; one has to
extract information from the HTML pages instead.</p>
<p>This document explores building a simple web spider and shows how its
performance can be improved using asynchronous processing. Along the way
is introduced the <code>async</code> and <code>await</code> operators
which allow you to write functions which can operate concurrently,
pausing and resuming as data become available.</p>
<div class="section level3">
<h3 id="a-simple-synchronous-web-spider">A simple (synchronous) web spider<a class="anchor" aria-label="anchor" href="#a-simple-synchronous-web-spider"></a>
</h3>
<p>For a simple case, say you wanted to gather the graph of a site –
every URL linked to from every page. You could use the <code>curl</code>
package to fetch web pages, and the <code>XML</code> package to parse
the links out of their content. Without using any asynchronous
processing, a simple web spider might look like this:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/jeroen/curl" class="external-link">curl</a></span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Using libcurl 7.81.0 with OpenSSL/3.0.2</span></span></code></pre>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://www.omegahat.net/RSXML/" class="external-link">XML</a></span><span class="op">)</span></span></code></pre></div>
<p>First we have a helper function to extract a list of links from a
downloaded web page.</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">extract_links</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">data</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">content</span></span>
<span>    <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/rawConversion.html" class="external-link">rawToChar</a></span><span class="op">(</span><span class="op">)</span></span>
<span>    <span class="op">|&gt;</span> <span class="fu">XML</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/XML/man/getHTMLLinks.html" class="external-link">getHTMLLinks</a></span><span class="op">(</span>externalOnly<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span></span>
<span>    <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">vapply</a></span><span class="op">(</span>FUN.VALUE<span class="op">=</span><span class="st">""</span>,</span>
<span>              \<span class="op">(</span><span class="va">link</span><span class="op">)</span> <span class="kw"><a href="https://rdrr.io/r/base/conditions.html" class="external-link">tryCatch</a></span><span class="op">(</span><span class="fu">XML</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/XML/man/getRelativeURL.html" class="external-link">getRelativeURL</a></span><span class="op">(</span><span class="va">link</span>, <span class="va">data</span><span class="op">$</span><span class="va">url</span>, addBase<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>                               error<span class="op">=</span>\<span class="op">(</span><span class="va">e</span><span class="op">)</span> <span class="cn">NA_character_</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/stats/na.fail.html" class="external-link">na.omit</a></span><span class="op">(</span><span class="op">)</span></span>
<span>    <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/character.html" class="external-link">as.character</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>Then the meat of the task is covered in this function:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">spider_site</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span></span>
<span>                        <span class="va">start_pages</span>, <span class="co">#starting URLs</span></span>
<span>                        <span class="va">regexp</span>,    <span class="co"># Linked URLs must match this to be</span></span>
<span>                        <span class="va">limit</span><span class="op">=</span><span class="fl">500</span><span class="op">)</span> <span class="op">{</span> <span class="co"># maximum number of pages to collect</span></span>
<span></span>
<span>  <span class="co">#all encountered pages will be collected in this hash table</span></span>
<span>  <span class="va">pages</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/environment.html" class="external-link">new.env</a></span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="co"># keep track of how many URLS seen and stop after a limit</span></span>
<span>  <span class="va">seen</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span></span>
<span>  <span class="co"># inner helper function:</span></span>
<span>  <span class="va">is_new_page</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">url</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="va">is_new</span> <span class="op">&lt;-</span> <span class="op">(</span><span class="va">seen</span> <span class="op">&lt;</span> <span class="va">limit</span><span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/exists.html" class="external-link">exists</a></span><span class="op">(</span><span class="va">url</span>, <span class="va">pages</span><span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="fu"><a href="https://rdrr.io/r/base/grep.html" class="external-link">grepl</a></span><span class="op">(</span><span class="va">regexp</span>, <span class="va">url</span><span class="op">)</span></span>
<span>    <span class="kw">if</span> <span class="op">(</span><span class="va">is_new</span><span class="op">)</span> <span class="op">{</span></span>
<span>      <span class="co">#mark this page as "in progress" and increment counter</span></span>
<span>      <span class="va">pages</span><span class="op">[[</span><span class="va">url</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="op">)</span></span>
<span>      <span class="va">seen</span> <span class="op">&lt;&lt;-</span> <span class="va">seen</span> <span class="op">+</span> <span class="fl">1</span></span>
<span>    <span class="op">}</span></span>
<span>    <span class="va">is_new</span></span>
<span>  <span class="op">}</span></span>
<span></span>
<span>  <span class="co"># define inner recursive function to visit a page</span></span>
<span>  <span class="va">visit_page</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">url</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/cat.html" class="external-link">cat</a></span><span class="op">(</span><span class="st">"visiting "</span>, <span class="va">url</span>, <span class="st">"\n"</span><span class="op">)</span></span>
<span></span>
<span>    <span class="co"># Fetch the page</span></span>
<span>    <span class="va">start_time</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Sys.time.html" class="external-link">Sys.time</a></span><span class="op">(</span><span class="op">)</span></span>
<span>    <span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/curl/man/curl_fetch.html" class="external-link">curl_fetch_memory</a></span><span class="op">(</span><span class="va">url</span><span class="op">)</span></span>
<span>    <span class="va">end_time</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Sys.time.html" class="external-link">Sys.time</a></span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span>    <span class="co"># extract the links and store our page in the hash table.</span></span>
<span>    <span class="va">links</span> <span class="op">&lt;-</span> <span class="fu">extract_links</span><span class="op">(</span><span class="va">data</span><span class="op">)</span> <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/unique.html" class="external-link">unique</a></span><span class="op">(</span><span class="op">)</span></span>
<span>    <span class="va">pages</span><span class="op">[[</span><span class="va">url</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span></span>
<span>      url <span class="op">=</span> <span class="va">url</span>, start <span class="op">=</span> <span class="va">start_time</span>, end <span class="op">=</span> <span class="va">end_time</span>, links <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/AsIs.html" class="external-link">I</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">links</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span>    <span class="co">#recursively follow new links, if within the site filter</span></span>
<span>    <span class="op">(</span> <span class="va">links</span></span>
<span>      <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/funprog.html" class="external-link">Filter</a></span><span class="op">(</span>f<span class="op">=</span><span class="va">is_new_page</span><span class="op">)</span></span>
<span>      <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">lapply</a></span><span class="op">(</span><span class="va">visit_page</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/invisible.html" class="external-link">invisible</a></span><span class="op">(</span><span class="cn">NULL</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span></span>
<span>  <span class="co"># Kick off by visiting each page in the starting set.</span></span>
<span>  <span class="va">start_pages</span> <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">lapply</a></span><span class="op">(</span><span class="va">visit_page</span><span class="op">)</span></span>
<span></span>
<span>  <span class="co">#Return our hash table as a data frame with "links" as a list-column.</span></span>
<span>  <span class="va">pages</span> <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">as.list</a></span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/do.call.html" class="external-link">do.call</a></span><span class="op">(</span>what<span class="op">=</span><span class="va">rbind</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>To narrate the above: The outer function <code>spider_site</code>
holds a hash table of all known pages, and that table is filled out by
calling inner function <code>visit_page</code>. In
<code>visit_page</code> we request and receive the web page, extract all
the links, and recursively follow any links that fall within the site
regexp – as long as those URLs haven’t been seen before</p>
<p>To spider a site, here, give it a starting function and a filtering
regexp, like so:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">spidered</span> <span class="op">&lt;-</span> <span class="fu">spider_site</span><span class="op">(</span><span class="st">"https://mysite.example/webapp"</span>, <span class="st">"mysite\\.example/"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/readRDS.html" class="external-link">saveRDS</a></span><span class="op">(</span><span class="va">spidered</span>, file<span class="op">=</span><span class="st">"spidered.rds"</span><span class="op">)</span></span></code></pre></div>
<p>(Since building packages should not perform a DDoS, the above is not
run in the vignette; I’ve included an example dataset instead.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">spidered</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/readRDS.html" class="external-link">readRDS</a></span><span class="op">(</span><span class="st">"spidered.rds"</span><span class="op">)</span></span></code></pre></div>
<p>The above spider is <em>synchronous;</em> when it requests a web
page, it waits for the entire page to be retrieved before continuing.
For <code>curl_fetch_memory</code> to return a value, it needs to open a
TCP connection to the remote server, send the request, wait for the
network to carry the request to the server; then the server must process
the request and send the result back over the network, then the client
must wait for the whole page to come over the network we can process a
list of links out of it.</p>
<p>Along the way we recorded “start” and “end” times, before we sent the
request and after we received the results. So we can visualize the time
course of our web spidering thus:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://ggplot2.tidyverse.org" class="external-link">ggplot2</a></span><span class="op">)</span></span>
<span><span class="va">time_plot</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">results</span><span class="op">)</span> <span class="op">(</span></span>
<span>  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html" class="external-link">ggplot</a></span><span class="op">(</span><span class="va">results</span><span class="op">)</span></span>
<span>  <span class="op">+</span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html" class="external-link">aes</a></span><span class="op">(</span>xmin<span class="op">=</span><span class="va">start</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min</a></span><span class="op">(</span><span class="va">start</span><span class="op">)</span>, xmax<span class="op">=</span><span class="va">end</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min</a></span><span class="op">(</span><span class="va">start</span><span class="op">)</span>, y<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/rank.html" class="external-link">rank</a></span><span class="op">(</span><span class="va">start</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="op">+</span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/scale_continuous.html" class="external-link">scale_x_continuous</a></span><span class="op">(</span><span class="st">"Elapsed(s)"</span>, breaks<span class="op">=</span><span class="fl">0</span><span class="op">:</span><span class="fl">16</span>, minor_breaks<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">16</span>, by<span class="op">=</span><span class="fl">0.5</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="op">+</span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/scale_continuous.html" class="external-link">scale_y_reverse</a></span><span class="op">(</span><span class="st">"Page #"</span><span class="op">)</span></span>
<span>  <span class="op">+</span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_errorbarh.html" class="external-link">geom_errorbarh</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="fu">time_plot</span><span class="op">(</span><span class="va">spidered</span><span class="op">)</span></span></code></pre></div>
<p><img src="spider_files/figure-html/unnamed-chunk-7-1.png" width="672"></p>
<p>Most of this time is spent waiting on the inherent latencies of the
network, rather than using the local CPU for anything. Latency can
become a bottleneck limiting the performance of any application that
relies on other servers. In this test
<code>R (curl.time / elapsed.time)*100</code>% of the time is spent
waiting for <code>curl</code>. The remainder of the time is spent on
parsing the HTML and extracting links.</p>
</div>
<div class="section level3">
<h3 id="concurrent-connections">Concurrent connections?<a class="anchor" aria-label="anchor" href="#concurrent-connections"></a>
</h3>
<p>For this reason, it would save a lot of time spent waiting if we
could be working on more than one connection at a time. In fact, package
<code>curl</code> does have a sort of asynchronous interface that allows
it to use multiple connections. You can request a page with
<code>curl_fetch_multi(url, done, fail)</code>, which accepts a pair of
callbacks for normal or error return values. Behind the scenes,
<code>libcurl</code> maintains a connection pool and can keep track of
multiple pending requests.</p>
<p>After you call <code>curl_fetch_multi</code>, at some point in the
future it will call the <code>done</code> or <code>fail</code>. There is
a catch, though: You need to periodically call
<code><a href="https://rdrr.io/pkg/curl/man/multi.html" class="external-link">curl::multi_run</a></code> to allow <code>libcurl</code> to do its
thing. Because <code>libcurl</code> does not run in a separate process;
it only does anything when R calls it. When you call
<code>curl_fetch_multi</code> curl will add your request to a queue, but
you need to call <code>multi_run</code> for it to perform the next steps
– sending, receiving, and assembling the received data.</p>
<p>So, to use concurrent connections, the above program could be
rewritten to. To sketch it out:</p>
<ul>
<li>
<code>visit_page</code> needs to have inner functions, say
<code>process_page</code> and <code>process_error</code>, to serve as
callbacks.</li>
<li>
<code>spider_site</code> would need to be built around a loop that
calls <code>multi_run</code> until all pages have been downloaded,
rather than a recursive function.</li>
</ul>
<p>This would amount to some restructuring of our program. But rather
than rewrite the whole logical flow of our spider, there’s a way to
abstract away most of the needed changes, That’s where the
<code>async</code> package comes in.</p>
</div>
<div class="section level3">
<h3 id="wiring-up-curl-to-promises">Wiring up <code>curl</code> to <code>promises</code><a class="anchor" aria-label="anchor" href="#wiring-up-curl-to-promises"></a>
</h3>
<p>Many things with asynchronous interfaces have their own ad-hoc APIs
for calling them; here <code>libcurl</code> uses
<code>curl_fetch_multi</code> and <code>multi_run</code>. The
<code>async</code> package relies on the <code>promise</code> class,
from package “<a href="https://rstudio.github.io/promises/" class="external-link">promises</a>,” as a unifying
abstraction for asynchronous requests. To use an ad hoc asynchronous API
with the <code>async</code> package, the first step is often to make a
shim presenting that that API in terms of promises.</p>
<p>Here is a function which accomplishes that:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://r-lib.github.io/later/" class="external-link">later</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://rstudio.github.io/promises/" class="external-link">promises</a></span><span class="op">)</span></span>
<span></span>
<span><span class="co"># global variable</span></span>
<span><span class="va">curl_is_active</span> <span class="op">&lt;-</span> <span class="cn">FALSE</span></span>
<span></span>
<span><span class="va">curl_fetch_async</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">url</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="co"># Promise constructor provides two callback functions</span></span>
<span>  <span class="co"># which fit right in curl_fetch_multi's arguments</span></span>
<span>  <span class="va">pr</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rstudio.github.io/promises//reference/promise.html" class="external-link">promise</a></span><span class="op">(</span><span class="kw">function</span><span class="op">(</span><span class="va">resolve</span>, <span class="va">reject</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/curl/man/curl_fetch.html" class="external-link">curl_fetch_multi</a></span><span class="op">(</span><span class="va">url</span>, done<span class="op">=</span><span class="va">resolve</span>, fail<span class="op">=</span><span class="va">reject</span><span class="op">)</span></span>
<span>    <span class="co"># since we've just told curl to do something new, let it start</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/curl/man/multi.html" class="external-link">multi_run</a></span><span class="op">(</span>timeout <span class="op">=</span> <span class="fl">0</span>, poll <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span>  <span class="op">}</span><span class="op">)</span></span>
<span></span>
<span>  <span class="co"># And then start checking it periodically</span></span>
<span>  <span class="kw">if</span> <span class="op">(</span><span class="op">!</span><span class="va">curl_is_active</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="va">curl_is_active</span> <span class="op">&lt;&lt;-</span> <span class="cn">TRUE</span></span>
<span>    <span class="fu"><a href="https://r-lib.github.io/later/reference/later.html" class="external-link">later</a></span><span class="op">(</span><span class="va">poll_curl</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span>  <span class="va">pr</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>The first part of <code>curl_fetch_async</code> is straightforward:
we call the <code>promise</code> constructor, which gives us two
callback functions <code>resolve</code>, and <code>reject</code>, that
plug right in to the arguments for <code>curl_fetch_multi</code>. So the
<code>promise</code> object is constructed that will represent the
pending page download.</p>
<p>Calling <code>curl_fetch_multi</code> just adds our request to
libcurl’s queue; The rest of the function has to do with arranging to
call <code>multi_run</code>, where <code>libcurl</code> actually does
its work. We call <code>multi_run</code> once after adding the request,
to allow it to start opening a connection. After creating the promise,
we check a global flag and if not set we call
<code>later(poll_curl)</code>. What this does is to arrange for
<code>poll_curl</code> (defined below) to be called later, in R’s event
loop.</p>
<div class="section level4">
<h4 id="the-event-loop">The event loop<a class="anchor" aria-label="anchor" href="#the-event-loop"></a>
</h4>
<p>R’s event loop runs while R is otherwise idle or awaiting input. R
enters the event loop when it is waiting for the user to give input at
the prompt; in the event loop R repeatedly checks for keyboard input as
well as other things, like network connections or GUI events.</p>
<p>For example, the builtin HTTP server <code><a href="https://rdrr.io/r/utils/help.start.html" class="external-link">help.start()</a></code> uses
the event loop; when it is active the event loop will periodically check
for and handle incoming HTTP connections. The Shiny web server also does
this. When a graphics window is open, the event loop is where R checks
for mouse clicks or window resizes. And the <code>promises</code>
package, and by extension <code>async</code> uses the event loop to
schedule processing.</p>
<p>The <a href="">later</a> package provides a simple interface for us
to to use R’s event loop to check in things. Above, in
<code>curl_fetch_async</code> we called <code>later(poll_curl)</code>,
which arranges for <code>poll_curl</code> to be called on the next run
through R’s event loop. Here is the definition of
<code>poll_curl</code>:</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">poll_curl</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="kw">if</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/curl/man/multi.html" class="external-link">multi_list</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span> <span class="op">==</span> <span class="fl">0</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="va">curl_is_active</span> <span class="op">&lt;&lt;-</span> <span class="cn">FALSE</span></span>
<span>  <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/curl/man/multi.html" class="external-link">multi_run</a></span><span class="op">(</span>timeout <span class="op">=</span> <span class="fl">0.001</span>, poll <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span>    <span class="fu"><a href="https://r-lib.github.io/later/reference/later.html" class="external-link">later</a></span><span class="op">(</span><span class="va">poll_curl</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>This calls curl’s <code>multi_run</code> which, given
<code>poll=TRUE</code> will do what it’s been tasked with – opening,
sending requests, and reading whatever data has been received. We give a
short timeout in case something else wants to use the event loop. And
finally we use <code>later</code> to do this again the next time through
the loop.</p>
<p>The global flag <code>curl_is_active</code> is used to keep from
cluttering up the event loop with multiple concurrent checks, and to
make sure we stop polling <code>curl</code> once all requests have been
filled.</p>
</div>
</div>
<div class="section level3">
<h3 id="an-asynchronous-spider">An Asynchronous Spider<a class="anchor" aria-label="anchor" href="#an-asynchronous-spider"></a>
</h3>
<p>Interfacing <code>curl</code> with <code>async</code> was the hard
part. Now that this is accomplished, making our spider asynchronous is
simple. Here is the asynchronous version of our web spider:</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://crowding.github.io/async/" class="external-link">async</a></span><span class="op">)</span></span>
<span><span class="va">spider_site_async</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/async.html">async</a></span><span class="op">(</span><span class="kw">function</span><span class="op">(</span></span>
<span>                        <span class="va">start_pages</span>, <span class="co">#starting URLs</span></span>
<span>                        <span class="va">regexp</span>,    <span class="co"># Linked URLs must match this to be</span></span>
<span>                        <span class="va">limit</span><span class="op">=</span><span class="fl">500</span><span class="op">)</span> <span class="op">{</span> <span class="co"># maximum number of pages to collect</span></span>
<span></span>
<span>  <span class="co">#all encountered pages will be collected in this hash table</span></span>
<span>  <span class="va">pages</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/environment.html" class="external-link">new.env</a></span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="co"># keep track of how many URLS seen and stop after a limit</span></span>
<span>  <span class="va">seen</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span></span>
<span>  <span class="co"># inner helper function:</span></span>
<span>  <span class="va">is_new_page</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">url</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="va">is_new</span> <span class="op">&lt;-</span> <span class="op">(</span><span class="va">seen</span> <span class="op">&lt;</span> <span class="va">limit</span><span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/exists.html" class="external-link">exists</a></span><span class="op">(</span><span class="va">url</span>, <span class="va">pages</span><span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="fu"><a href="https://rdrr.io/r/base/grep.html" class="external-link">grepl</a></span><span class="op">(</span><span class="va">regexp</span>, <span class="va">url</span><span class="op">)</span></span>
<span>    <span class="kw">if</span> <span class="op">(</span><span class="va">is_new</span><span class="op">)</span> <span class="op">{</span></span>
<span>      <span class="co">#mark this page as "in progress" and increment counter</span></span>
<span>      <span class="va">pages</span><span class="op">[[</span><span class="va">url</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="op">)</span></span>
<span>      <span class="va">seen</span> <span class="op">&lt;&lt;-</span> <span class="va">seen</span> <span class="op">+</span> <span class="fl">1</span></span>
<span>    <span class="op">}</span></span>
<span>    <span class="va">is_new</span></span>
<span>  <span class="op">}</span></span>
<span></span>
<span>  <span class="co"># define inner recursive function to visit a page</span></span>
<span>  <span class="va">visit_page</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/async.html">async</a></span><span class="op">(</span><span class="kw">function</span><span class="op">(</span><span class="va">url</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/cat.html" class="external-link">cat</a></span><span class="op">(</span><span class="st">"visiting (async) "</span>, <span class="va">url</span>, <span class="st">"\n"</span><span class="op">)</span></span>
<span></span>
<span>    <span class="co"># Fetch the page</span></span>
<span>    <span class="va">start_time</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Sys.time.html" class="external-link">Sys.time</a></span><span class="op">(</span><span class="op">)</span></span>
<span>    <span class="va">data</span> <span class="op">&lt;-</span> <span class="fu">curl_fetch_async</span><span class="op">(</span><span class="va">url</span><span class="op">)</span> <span class="op">|&gt;</span> <span class="fu"><a href="../reference/async.html">await</a></span><span class="op">(</span><span class="op">)</span></span>
<span>    <span class="va">end_time</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Sys.time.html" class="external-link">Sys.time</a></span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span>    <span class="co"># extract the links and store our page in the hash table.</span></span>
<span>    <span class="va">links</span> <span class="op">&lt;-</span> <span class="fu">extract_links</span><span class="op">(</span><span class="va">data</span><span class="op">)</span> <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/unique.html" class="external-link">unique</a></span><span class="op">(</span><span class="op">)</span></span>
<span>    <span class="va">pages</span><span class="op">[[</span><span class="va">url</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span></span>
<span>      url <span class="op">=</span> <span class="va">url</span>, start <span class="op">=</span> <span class="va">start_time</span>, end <span class="op">=</span> <span class="va">end_time</span>, links <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/AsIs.html" class="external-link">I</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">links</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span>    <span class="co">#recursively follow new links, if within the site filter</span></span>
<span>    <span class="op">(</span> <span class="va">links</span></span>
<span>      <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/funprog.html" class="external-link">Filter</a></span><span class="op">(</span>f<span class="op">=</span><span class="va">is_new_page</span><span class="op">)</span></span>
<span>      <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">lapply</a></span><span class="op">(</span><span class="va">visit_page</span><span class="op">)</span></span>
<span>      <span class="op">|&gt;</span> <span class="fu"><a href="https://rstudio.github.io/promises//reference/promise_all.html" class="external-link">promise_all</a></span><span class="op">(</span>.list<span class="op">=</span><span class="va">_</span><span class="op">)</span></span>
<span>      <span class="op">|&gt;</span> <span class="fu"><a href="../reference/async.html">await</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/invisible.html" class="external-link">invisible</a></span><span class="op">(</span><span class="cn">NULL</span><span class="op">)</span></span>
<span>  <span class="op">}</span><span class="op">)</span></span>
<span></span>
<span>  <span class="co"># Kick off by visiting each page in the starting set.</span></span>
<span>  <span class="va">start_pages</span> <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">lapply</a></span><span class="op">(</span><span class="va">visit_page</span><span class="op">)</span> <span class="op">|&gt;</span> <span class="fu"><a href="https://rstudio.github.io/promises//reference/promise_all.html" class="external-link">promise_all</a></span><span class="op">(</span>.list<span class="op">=</span><span class="va">_</span><span class="op">)</span> <span class="op">|&gt;</span> <span class="fu"><a href="../reference/async.html">await</a></span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span>  <span class="co">#Return our hash table as a data frame with "links" as a list-column.</span></span>
<span>  <span class="va">pages</span> <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">as.list</a></span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/do.call.html" class="external-link">do.call</a></span><span class="op">(</span>what<span class="op">=</span><span class="va">rbind</span><span class="op">)</span></span>
<span><span class="op">}</span><span class="op">)</span></span></code></pre></div>
<p>For the most part, this is almost identical to the non-asynchronous
version. In fact the only differences are:</p>
<ul>
<li>Function definitions for <code>spider_site</code> and
<code>visit_page</code> are both wrapped in <code>async</code>.</li>
<li>The call to <code><a href="https://rdrr.io/pkg/curl/man/curl_fetch.html" class="external-link">curl_fetch_memory()</a></code> is replaced by
<code>curl_fetch_async(url)</code> (which we defined above) followed by
<code><a href="../reference/async.html">await()</a></code>.</li>
<li>Both calls to <code>lapply(visit_page)</code> are followed by
<code>|&gt; promise_all(.list=_) |&gt; await()</code>.</li>
</ul>
<p>Wrapping a function definition in <code>async</code> creates an async
function. This is effectively a function that can pause and resume.
Calling an async function does not execute the function immediately, but
returns a promise, that will be resolved with the function’s eventual
return value. The function will actually begin executing the next time R
runs the event loop.</p>
<p>When an async function reaches a call to <code>await(x)</code>, it
pauses, allowing R’s event loop to continue. The argument to
<code>await</code> should be a promise. After that promise resolves, the
awaiting function will then resume with that value.</p>
<div class="section level4">
<h4 id="a-single-thread-dividing-attention-between-tasks">A single thread, dividing attention between tasks<a class="anchor" aria-label="anchor" href="#a-single-thread-dividing-attention-between-tasks"></a>
</h4>
<p>To unpack the phrase
<code>lapply(visit_page) |&gt; promise_all() |&gt; await()</code>: As
<code>visit_page</code> is now an async function,
<code>lapply(visit_page)</code> will create a list of <em>promises</em>.
<a href="https://rstudio.github.io/promises/reference/promise_all.html" class="external-link"><code>promise_all()</code></a>
combines them into one promise. The <code><a href="../reference/async.html">await()</a></code> then causes the
outer function to pause and return to the event loop. In total, this
phrase means to make several asynchronous calls to
<code>visit_page</code>, then pause until all of those calls have
resolved. Effectively, this makes several concurrent calls to
<code>visit_page</code>.</p>
<p>When the outer function pauses, R will then be free to move to the
next task in the event loop, namely to start running the first of those
<code>visit_page</code> calls. It calls <code>curl_fetch_async</code>
and pauses, causing a new task is added to the queue: call
<code>poll_curl</code>. Each of the other calls to
<code>visit_page</code> do so in turn.</p>
<p>Then the event loop gets to <code>poll_curl</code>, which calls
<code>multi_run</code> which finally allows libcurl to get to work,
opening connections and sending requests. When the first received page
is complete, <code>curl_fetch_async</code>’s promise resolves, allowing
the calling <code>visit_page</code> to resume; it now can run and
extract the links from the page. Having done so, it adds a few more
<code>visit_page</code> calls to the event queue, and so on we go
recursively.</p>
<p>The effect is, our concurrent spider is doing everything the
non-concurrent one did, in the same <em>logical</em> order, given that
the code is nearly the same and all, but in a different
<em>temporal</em> order. Putting a few <code>await</code> calls here and
there allowed the task to be divided up in pieces that could run without
waiting on each other.</p>
<p>You can view the way we are using async functions and event loop here
as a form of “cooperative” multitasking; dividing a single thread’s
attention across several concerns.</p>
</div>
</div>
<div class="section level3">
<h3 id="how-does-it-run">How does it run?<a class="anchor" aria-label="anchor" href="#how-does-it-run"></a>
</h3>
<p>As we have recorded a timestamp when we start and finish each
request, we can illustrate the difference in performance.</p>
<p>Now let’s compare the asynchronous and synchronous versions of the
same pipeline.</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">spidered</span> <span class="op">&lt;-</span> <span class="fu">spider_site</span><span class="op">(</span><span class="st">"https://mysite.example/webapp"</span>, <span class="st">"mysite\\.example/"</span><span class="op">)</span></span>
<span><span class="va">spidered_async</span> <span class="op">|&gt;</span> <span class="fu"><a href="https://rstudio.github.io/promises//reference/then.html" class="external-link">then</a></span><span class="op">(</span>\<span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="va">x</span> <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/readRDS.html" class="external-link">saveRDS</a></span><span class="op">(</span><span class="st">"spidered_async.rds"</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>(Again, the above isn’t run in the vignette; here’s a precomputed
test file.)</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">spidered_async_data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/readRDS.html" class="external-link">readRDS</a></span><span class="op">(</span><span class="st">"spidered_async.rds"</span><span class="op">)</span></span></code></pre></div>
<p>Let’s look at the elapsed time for both runs on the same chart:</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://dplyr.tidyverse.org" class="external-link">dplyr</a></span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Attaching package: 'dplyr'</span></span></code></pre>
<pre><code><span><span class="co">## The following objects are masked from 'package:async':</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##     collect, combine</span></span></code></pre>
<pre><code><span><span class="co">## The following objects are masked from 'package:stats':</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##     filter, lag</span></span></code></pre>
<pre><code><span><span class="co">## The following objects are masked from 'package:base':</span></span>
<span><span class="co">## </span></span>
<span><span class="co">##     intersect, setdiff, setequal, union</span></span></code></pre>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">spidered</span> <span class="op">&lt;-</span> <span class="op">(</span><span class="va">spidered</span></span>
<span>  <span class="op">|&gt;</span> <span class="fu"><a href="https://dplyr.tidyverse.org/reference/mutate.html" class="external-link">mutate</a></span><span class="op">(</span>method<span class="op">=</span><span class="st">"sync"</span>, order<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/rank.html" class="external-link">rank</a></span><span class="op">(</span><span class="va">start</span><span class="op">)</span>,</span>
<span>            end<span class="op">=</span><span class="va">end</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min</a></span><span class="op">(</span><span class="va">start</span><span class="op">)</span>, start<span class="op">=</span><span class="va">start</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min</a></span><span class="op">(</span><span class="va">start</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">spidered_async_data</span> <span class="op">&lt;-</span> <span class="op">(</span><span class="va">spidered_async_data</span></span>
<span>  <span class="op">|&gt;</span> <span class="fu"><a href="https://dplyr.tidyverse.org/reference/mutate.html" class="external-link">mutate</a></span><span class="op">(</span>method<span class="op">=</span><span class="st">"async"</span>, order<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/rank.html" class="external-link">rank</a></span><span class="op">(</span><span class="va">start</span><span class="op">)</span>,</span>
<span>             end<span class="op">=</span><span class="va">end</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min</a></span><span class="op">(</span><span class="va">start</span><span class="op">)</span>, start<span class="op">=</span><span class="va">start</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min</a></span><span class="op">(</span><span class="va">start</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">rbind</a></span><span class="op">(</span><span class="va">spidered</span>, <span class="va">spidered_async_data</span><span class="op">)</span></span>
<span>  <span class="op">|&gt;</span> <span class="fu">time_plot</span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="op">+</span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html" class="external-link">aes</a></span><span class="op">(</span>y<span class="op">=</span><span class="va">order</span>, color<span class="op">=</span><span class="va">method</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="spider_files/figure-html/unnamed-chunk-16-1.png" width="672"></p>
<p>We can see that in the asynchronous version, page requests overlap;
one page does not have to be received and processed for it to start
working on the next. This allows for there to be several requests “in
the air” at any one time. The pages are processed and links are
extracted as the results come back. Concurrency allows the whole task to
be done quicker. As a side effect, any individual request takes longer
to be completed; Increasing throughput with concurrency often does have
the effect of increasing the latency for any one element of data to be
processed. Much of the latency between <code>start</code> and
<code>end</code> is actually accounted for by the request waiting in
licurl’s queue, as libcurl has a sensible default maximum of 6
concurrent connections for a single host.</p>
</div>
<div class="section level2">
<h2 id="conclusion">Conclusion<a class="anchor" aria-label="anchor" href="#conclusion"></a>
</h2>
<p>The <code>async</code>/<code>await</code> construct helps a
single-threaded R process to interact with a concurrent world. Using
<code>async</code>, your programs can have a familiar sequential
structure, but multiple async functions can run concurrently as process
data as it becomes available. This means your program can spend less
time waiting and more time processing.</p>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Peter Meilstrup.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

      </footer>
</div>

  


  

  </body>
</html>
