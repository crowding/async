<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Coroutine Language • async</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="The Coroutine Language">
<meta property="og:description" content="async">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    

    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">async</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">0.3.1</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/README.html">The `async` package: Generators, async/await, and asynchronous streams for R</a>
    </li>
    <li>
      <a href="../articles/clapping.html">A Musical Introduction to Generators</a>
    </li>
    <li>
      <a href="../articles/language.html">The Coroutine Language</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/crowding/async/" class="external-link">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>The Coroutine Language</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/crowding/async/blob/HEAD/vignettes/language.Rmd" class="external-link"><code>vignettes/language.Rmd</code></a></small>
      <div class="hidden name"><code>language.Rmd</code></div>

    </div>

    
    
<p>The <code>async</code> package allows you to write code that executes
incrementally.</p>
<p>When an ordinary R function is called, control does not return until
that function either produces a value, or finishes with an error. A
<code>async({})</code> block. will run until it reaches an
<code>await(pr)</code> and pauses, returning control until the value of
promise <code>pr</code> is available. So a coroutine’s evaluation can be
temporally interleaved with other operations.</p>
<p>However, this does not require any changes to R’s execution model;
coroutines are implemented in terms of base R, within its
single-threaded execution model. In order to pause and resume, a
coroutine has to explicitly keep track of its internal state. When it
reaches <code>yield</code> it saves its place, then resumes on the next
<code>nextOr</code>.</p>
<p>In other words a generator is a kind of state machine sitting behind
the <code>iteror</code> interface. An <code>async</code> also operates
as a kind of state machine, one that interacts with
the<code>promise</code> interface; its state advances according to its
program and how awaited promises and other calls resolve.</p>
<p>The particular state transitions, and the internal state that is
tracked, are constructed from the coroutine expression. In other words
you could say that the <code>async</code> package implements a
mini-language for describing state machines.</p>
<p>The illusion that a coroutine works like a parallel stream of R code
is due to this mini-language being constructed to function analogously
to base R. However, the language is <em>slightly</em> different from
base R, so this document tries to collect and explain those differences,
and tries to paint a picture of how these objects operate.</p>
<div class="section level3">
<h3 id="basics-pausable-functions">Basics: Pausable functions<a class="anchor" aria-label="anchor" href="#basics-pausable-functions"></a>
</h3>
<p>The first thing to know about the coroutine mini-language is that a
<code><a href="../reference/gen.html">yield()</a></code> or <code><a href="../reference/async.html">await()</a></code> can only appear under the
arguments of “pausable” functions. The <code>async</code> package has
built in pausable implementations of R’s most commonly used control flow
and error handling functions. The function
<code><a href="../reference/pausables.html">async::pausables()</a></code> will return a list of all pausable
functions it can see. As of this writing, the list is:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://crowding.github.io/async/" class="external-link">async</a></span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/pausables.html">pausables</a></span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">vapply</a></span><span class="op">(</span><span class="va">as.character</span>, <span class="st">""</span><span class="op">)</span> <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/sort.html" class="external-link">sort</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##  [1] "("         "{"         "&amp;&amp;"        "&lt;-"        "&lt;&lt;-"       "||"       </span></span>
<span><span class="co">##  [7] "await"     "awaitNext" "break"     "for"       "goto"      "if"       </span></span>
<span><span class="co">## [13] "next"      "nextOr"    "on.exit"   "repeat"    "return"    "switch"   </span></span>
<span><span class="co">## [19] "try"       "tryCatch"  "while"     "yield"     "yieldFrom"</span></span></code></pre>
<p>While any R functions can be used in a coroutine expression,
<code>yield</code> or <code>await</code> can only appear within the
arguments of the above functions. This restriction applies recursively;
the following is illegal because <code>list</code> is not pausable.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">L</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/run.html">run</a></span><span class="op">(</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span> <span class="kw">if</span> <span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="fu"><a href="../reference/gen.html">yield</a></span><span class="op">(</span><span class="va">y</span><span class="op">)</span> <span class="kw">else</span> <span class="fu"><a href="../reference/gen.html">yield</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">)</span> <span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Error in trans_call(expr, path): A pause or break appears in an argument to `list`, which is not pausable. Consider using split_pipes=TRUE</span></span></code></pre>
<p>The error message refers to option <code>split_pipes</code>, which
offers a workaround. If <code>split_pipes=TRUE</code>, an await in the
leftmost argument of a function can be rewritten using a temp variable.
<code>async({await(x) + 5})</code> will be rewritten using the “base R
pipe” i.e. <code>async({await(x) -&gt;.; . + 5})</code></p>
</div>
<div class="section level3">
<h3 id="coroutines-vs--functions">Coroutines vs. functions<a class="anchor" aria-label="anchor" href="#coroutines-vs--functions"></a>
</h3>
<p>Constructing a <code>gen</code> or <code>async</code> is somewhat
like calling a <em>function</em>, in that it creates a new environment,
executes a given block of code with respect to that environment, and
supports actions like <code><a href="https://rdrr.io/r/base/Control.html" class="external-link">break</a></code>, <code>return</code>,
<code>stop</code>, and <code>on,exit</code>. that apply to a scope.
Coroutine constructors by themselves do not take arguments; to create a
generator with respect to some argument, you simply write a function
that takes and argument and returns a generator:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># given a sequence of sequences, concatenate them like c() into one sequence</span></span>
<span><span class="va">chain</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">sequences</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/force.html" class="external-link">force</a></span><span class="op">(</span><span class="va">sequences</span><span class="op">)</span></span>
<span>  <span class="fu"><a href="../reference/gen.html">gen</a></span><span class="op">(</span><span class="op">{</span></span>
<span>    <span class="kw">for</span> <span class="op">(</span><span class="va">seq</span> <span class="kw">in</span> <span class="va">sequences</span><span class="op">)</span> <span class="op">{</span></span>
<span>      <span class="fu"><a href="../reference/gen.html">yieldFrom</a></span><span class="op">(</span><span class="va">seq</span><span class="op">)</span></span>
<span>    <span class="op">}</span></span>
<span>  <span class="op">}</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>Note that it is a good practice in R to <code><a href="https://rdrr.io/r/base/force.html" class="external-link">force()</a></code> the
function arguments, as in any case when a function returns an inner
construct that captures its scope. Because it’s easy to forget to force
arguments, the <code>async</code> package offers a “generator function”
syntax. So the above can be rewritten as:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">chain</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/gen.html">gen</a></span><span class="op">(</span><span class="kw">function</span><span class="op">(</span><span class="va">sequences</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="kw">for</span><span class="op">(</span><span class="va">seq</span> <span class="kw">in</span> <span class="va">sequences</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="fu"><a href="../reference/gen.html">yieldFrom</a></span><span class="op">(</span><span class="va">seq</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span><span class="op">)</span></span></code></pre></div>
<p>All that is going on here is when <code>gen</code> sees
<code>function</code> as the head of its expression, it just adds the
<code>force</code> and moves the call to “gen” inside the function,
reproducing the earlier version..</p>
</div>
<div class="section level3">
<h3 id="functions-in-coroutines">Functions in coroutines<a class="anchor" aria-label="anchor" href="#functions-in-coroutines"></a>
</h3>
<p>Coroutines do not have a stack or a notion of procedure calls;
function definition is left to R, and the coroutine parser will ignore
anything written in a function definition. If you write an inner
function in a generator, that inner function will not be able to
<code>yield</code>.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">names</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Ana"</span>, <span class="st">"Bob"</span>, <span class="st">"Charlie"</span><span class="op">)</span></span>
<span><span class="va">g</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/gen.html">gen</a></span><span class="op">(</span><span class="op">{</span></span>
<span>  <span class="va">greet</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">name</span><span class="op">)</span> <span class="fu"><a href="../reference/gen.html">yield</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste0</a></span><span class="op">(</span><span class="st">"Good morning, "</span>, <span class="va">name</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="va">names</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="fu">greet</span><span class="op">(</span><span class="va">name</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">as.list</a></span><span class="op">(</span><span class="va">g</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Error in yield(paste0("Good morning, ", name)): yield() called outside a generator</span></span></code></pre>
<p>However, you can use <code><a href="../reference/gen.html">yieldFrom()</a></code> to return any number of
values from another iterator.</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">names</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Ana"</span>, <span class="st">"Bob"</span>, <span class="st">"Charlie"</span><span class="op">)</span></span>
<span><span class="va">greet</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/gen.html">gen</a></span><span class="op">(</span><span class="kw">function</span><span class="op">(</span><span class="va">name</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="../reference/gen.html">yield</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste0</a></span><span class="op">(</span><span class="st">"Good morning, "</span>, <span class="va">name</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">}</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/run.html">run</a></span><span class="op">(</span>type<span class="op">=</span><span class="st">""</span>, <span class="op">{</span></span>
<span>  <span class="kw">for</span> <span class="op">(</span><span class="va">n</span> <span class="kw">in</span> <span class="va">names</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="fu"><a href="../reference/gen.html">yieldFrom</a></span><span class="op">(</span><span class="fu">greet</span><span class="op">(</span><span class="va">n</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] "Good morning, Ana"     "Good morning, Bob"     "Good morning, Charlie"</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="loops">Loops<a class="anchor" aria-label="anchor" href="#loops"></a>
</h3>
<p><code>for</code> loops in a coroutine can run over iterators as well
as plain vectors. The <code>in</code> argument to a <code>for</code>
loop will be converted to the <code>iteror</code> interface using
<code>iteror(x)</code>.</p>
<p>When writing an <code>async</code> or <code>stream</code> routine,
<code>for</code> loops can be used to consume values from
channels/streams, without explicitly calling <code><a href="../reference/async.html">await()</a></code>.</p>
<p><code>repeat</code>, <code>while</code> and <code>for</code>
otherwise work like in base R, including support for <code><a href="https://rdrr.io/r/base/Control.html" class="external-link">next</a></code>
and <code><a href="https://rdrr.io/r/base/Control.html" class="external-link">break</a></code> operators.</p>
<p>You can also write looping code by using <code><a href="https://rdrr.io/r/base/switch.html" class="external-link">switch()</a></code> with
<code><a href="../reference/switch.html">goto()</a></code>, described below.</p>
</div>
<div class="section level3">
<h3 id="conditionals-and-branches">Conditionals and branches<a class="anchor" aria-label="anchor" href="#conditionals-and-branches"></a>
</h3>
<div class="section level4">
<h4 id="logical-branching-if">Logical branching: <code>if</code>, <code>||</code>
<code>&amp;&amp;</code><a class="anchor" aria-label="anchor" href="#logical-branching-if"></a>
</h4>
<p>Coroutine <code>if</code> statements work similarly to base R.</p>
<p>Short circuiting logical operators <code>||</code> and
<code>&amp;&amp;</code> will try first their left branch, which must
return a scalar logical. If not satisfied with the left branch, they
will evaluate the right argument and return it directly. That is, in a
coroutine <code>yield(TRUE) &amp;&amp; "string"</code> may return
“string”, while in base R this raises an error.</p>
<p>I write “may” above, because if you write <code>||</code> in a
coroutine expression you might be using either base R <code>||</code> or
the pausable version of <code>||</code>. In general you will only be
using pausable <code>||</code> if there is a pause somewhere on either
side of it. So if you write <code>(x == 5) || FALSE</code> you will be
using base R <code>||</code>, since <code>==</code> does not pause.
Whereas if you write
<code>(await(success) == 5) || yield("assertion")</code> you will be
using pausable <code>||</code>, because there is an <code>await</code>
on one side of it.</p>
</div>
<div class="section level4">
<h4 id="switch-and-goto">
<code>switch</code> and <code>goto</code><a class="anchor" aria-label="anchor" href="#switch-and-goto"></a>
</h4>
<p><code><a href="https://rdrr.io/r/base/switch.html" class="external-link">switch()</a></code> statements are more strict than in base R; the
input to a <code>switch</code> <em>must</em> match a given branch or it
will raise an error. That is, in base R,
<code>switch(-1, "not run")</code> or
<code>switch("bar", foo="not run")</code> returns invisible
<code>NULL</code>, while in a coroutine this is an error.</p>
<p>Additionally, <code>switch</code> statements support a <em>delimited
goto</em>. Within a given <code>switch</code> statement,
<code>goto("other_branch")</code> stops executing the present branch and
jumps to the given sibling branch. Calling <code><a href="../reference/switch.html">goto()</a></code> without
arguments re-reads the switch input again. For example, you might try to
read an input file that might be in a few different formats.</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">file_dataset</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/async.html">async</a></span><span class="op">(</span><span class="op">{</span></span>
<span>  <span class="va">filename</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/async.html">await</a></span><span class="op">(</span> <span class="fu">download_file</span><span class="op">(</span><span class="va">url</span><span class="op">)</span> <span class="op">)</span></span>
<span>  <span class="kw"><a href="https://rdrr.io/r/base/switch.html" class="external-link">switch</a></span><span class="op">(</span><span class="fu">getExtension</span><span class="op">(</span><span class="va">filename</span><span class="op">)</span>,</span>
<span>      <span class="st">"txt"</span><span class="op">=</span><span class="fu">readTxt</span><span class="op">(</span><span class="va">filename</span><span class="op">)</span>,</span>
<span>      <span class="st">"csv"</span><span class="op">=</span><span class="kw"><a href="https://rdrr.io/r/base/conditions.html" class="external-link">tryCatch</a></span><span class="op">(</span><span class="fu">readCSV</span><span class="op">(</span><span class="va">filename</span><span class="op">)</span>, error<span class="op">=</span><span class="fu"><a href="../reference/switch.html">goto</a></span><span class="op">(</span><span class="st">"txt"</span><span class="op">)</span><span class="op">)</span>,</span>
<span>      <span class="st">"json"</span><span class="op">=</span><span class="op">{</span></span>
<span>          <span class="kw">if</span> <span class="op">(</span><span class="op">!</span><span class="fu"><a href="../reference/async.html">await</a></span><span class="op">(</span><span class="fu">validateSchema</span><span class="op">(</span><span class="va">filename</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> <span class="fu"><a href="../reference/switch.html">goto</a></span><span class="op">(</span><span class="st">"txt"</span><span class="op">)</span></span>
<span>          <span class="kw"><a href="https://rdrr.io/r/base/conditions.html" class="external-link">tryCatch</a></span><span class="op">(</span><span class="fu">read_json</span><span class="op">(</span><span class="va">filename</span><span class="op">)</span>, error<span class="op">=</span><span class="fu"><a href="../reference/switch.html">goto</a></span><span class="op">(</span><span class="st">"txt"</span><span class="op">)</span><span class="op">)</span></span>
<span>      <span class="op">}</span>,</span>
<span>      <span class="st">"zip"</span><span class="op">=</span> <span class="op">{</span></span>
<span>          <span class="va">unzipped</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/utils/unzip.html" class="external-link">unzip</a></span><span class="op">(</span><span class="va">filename</span><span class="op">)</span></span>
<span>          <span class="fu"><a href="https://rdrr.io/r/base/on.exit.html" class="external-link">on.exit</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/unlink.html" class="external-link">unlink</a></span><span class="op">(</span><span class="va">unzipped</span><span class="op">)</span><span class="op">)</span></span>
<span>          <span class="fu"><a href="https://rdrr.io/r/utils/unzip.html" class="external-link">unzip</a></span><span class="op">(</span><span class="va">filename</span><span class="op">)</span></span>
<span>          <span class="fu"><a href="../reference/switch.html">goto</a></span><span class="op">(</span><span class="op">)</span> <span class="co"># i.e. run getExtension on the new filename</span></span>
<span>      <span class="op">}</span></span>
<span>  <span class="op">)</span></span>
<span><span class="op">}</span><span class="op">)</span></span></code></pre></div>
<p>Here, if there is an error in reading a <code>.csv</code> or
<code>.json</code> file we re-try ingesting it as a text file; on
encountering a <code>zip</code> file we unzip it and try again with the
new filename. If a <code>goto</code> appears inside of a
<code>try(..., finally={...})</code> call, which is itself inside a
branch, the <code>finally</code> clause will be executed <em>before</em>
jumping to the new branch.</p>
</div>
</div>
<div class="section level3">
<h3 id="whats-under-the-hood-coroutines-are-state-machines-which-are-graphs">What’s under the hood? Coroutines are state machines, which are
graphs<a class="anchor" aria-label="anchor" href="#whats-under-the-hood-coroutines-are-state-machines-which-are-graphs"></a>
</h3>
<p>All of this sequencing we are discussing through this document is
baked into a sort of graph structure when a generator is constructed.
See if you can follow the logic of the preceding <code>async</code>
through its graph:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/graphAsync.html">graphAsync</a></span><span class="op">(</span><span class="va">file_dataset</span>, type<span class="op">=</span><span class="st">"svg"</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="file_dataset.svg" style="width:100.0%" alt=""><p class="caption">A directed graph</p>
</div>
<p>Is it a bit spaghetti? Here we have nodes for each discrete step in
the computation. Nodes in reverse type are user-level R calls, there are
a few grouped nodes to handle an <code>await</code> or
<code>tryCatch</code>.</p>
<p>Each node in the graph is literally a function and each line
represents where it calls the next function. You can step through these
if you set <code>debugAsync(as, debugInternal=TRUE)</code>.</p>
<p>Saving state, then, is just remembering the last call. (Dotted lines,
here, represent where it saves state rather</p>
</div>
<div class="section level3">
<h3 id="starting-pausing-finishing-errors-and-cleanup">Starting, pausing, finishing, errors, and cleanup<a class="anchor" aria-label="anchor" href="#starting-pausing-finishing-errors-and-cleanup"></a>
</h3>
<p>Starting and finishing may mean different things for different
coroutines.</p>
<div class="section level4">
<h4 id="starting">Starting<a class="anchor" aria-label="anchor" href="#starting"></a>
</h4>
<ul>
<li>
<code>run</code> is “eager;” executes an entire coroutine expression
immediately without pausing.</li>
<li>Generators are “lazy;” at the start, a <code>gen</code> does not
compute anything when it is first constructed, it only begins executing
when there is a request for data via <code>nextOr</code>.</li>
<li>
<code>async</code> routines are “eager;” they begin executing
immediately on creation, before the constructor returns. An
<code>async</code> runs until it gets the first <code>await</code> and
then pauses. allowing the constructor to return. Upon receiving, the
async will continue running.</li>
<li>
<code>stream</code> objects can run in either lazy or eager mode. If
<code>lazy=TRUE</code>, they will not compute anything until something
calls the channel’s <code>nextThen</code> method, and will pause after
<code>yield</code> if there are no more listeners. If
<code>lazy=FALSE</code>, a stream starts executing when constructed,
will not pause after <code>yield</code>, and may run ahead and queue up
outgoing values until it reaches an <code>await</code>.</li>
</ul>
</div>
<div class="section level4">
<h4 id="pausing">Pausing<a class="anchor" aria-label="anchor" href="#pausing"></a>
</h4>
<ul>
<li>
<code>await(p)</code> in an <code>async</code> or stream, pauses
execution until the given promise resolves.</li>
<li>
<code>yield(val)</code> in a generator pauses execution, returns the
given value as the result of <code><a href="../reference/iteror.html">nextOr()</a></code>.</li>
<li>
<code>yield(val)</code> in a stream, resolves the next listener with
the value given. It may or may not pause depending on whether
<code>lazy=TRUE</code> and whether there are any more pending
requests/</li>
<li>
<code>yieldFrom(i)</code> takes an iterator <em>or</em> a stream as
argument, and yields successive values until it is exhausted.
<code>yieldFrom(iter)</code> is basically equivalent to
<code>for (i in iter) yield(i)</code>.</li>
</ul>
</div>
<div class="section level4">
<h4 id="finishing">Finishing<a class="anchor" aria-label="anchor" href="#finishing"></a>
</h4>
<p>A coroutine might finish normally by reaching a call to
<code>return(...)</code>, or by simply reaching the end of its
expression.</p>
<p>If a coroutine reaches a <code>return</code> call, all enclosing
<code>tryCatch(finally=)</code> and <code>on.exit</code> handlers will
be executed before returning the value.</p>
<ul>
<li>When a generator finishes normally, the present call
<code>nextOr</code>() forces its <code>or</code> argument. The value
returned by the generator expression is discarded.</li>
<li>When an <code>async</code> finishes normally , its promise interface
resolves with the return value.</li>
<li>When a stream finishes normally, the listeners will be notified of a
close <em>after</em> any remaining messages have been read from the
channel’s outgoing queue.</li>
</ul>
</div>
<div class="section level4">
<h4 id="errors">Errors<a class="anchor" aria-label="anchor" href="#errors"></a>
</h4>
<p>A coroutine might finish abnormally if the user-level R code throws
an error, or if there is an internal error in the coroutine
implementation.</p>
<ul>
<li>When a <code>gen</code> or <code>run</code> routine finishes
abnormally, all <code>on.exit</code> clauses are triggered, while the
inciting error is allowed to propagate normally without being
caught.</li>
<li>If a <code>async</code> routine throws an error, it will be caught
and the error will be forwarded to reject a promise.</li>
</ul>
</div>
<div class="section level4">
<h4 id="cleanup">Cleanup<a class="anchor" aria-label="anchor" href="#cleanup"></a>
</h4>
<p><code>on.exit</code> handlers are run in a special phase after main
execution finishes (either normally or abnormally). After
<code>on.exit</code> handlers have all finished, the coroutine will
continue to propagate its error or its return value.</p>
<p>If you were to do something as strange as <code><a href="https://rdrr.io/r/base/function.html" class="external-link">return()</a></code> or
<code><a href="../reference/gen.html">yield()</a></code> from an on.exit handler, any pending error will be
cancelled. (This is also how base R’s <code>on.exit</code> behaves.)</p>
</div>
</div>
<div class="section level3">
<h3 id="exception-handling">Exception handling<a class="anchor" aria-label="anchor" href="#exception-handling"></a>
</h3>
<p>Errors during execution can come from user-level R code, or,
possibly, from within the coroutine implementation itself. The coroutine
implementation of <code>tryCatch</code> tries to be able to catch either
type. When a coroutine enters a <code>tryCatch</code>, it briefly saves
state so that it can wind up an R-level <code>tryCatch</code> and
continuing underneath it. This way it can catch exceptions coming from
both the coroutine implementation and user-level R calls.</p>
<p>A slight difference from base R <code>tryCatch</code> is you can
supply a non- function value to <code>error</code> if you don’t care
about parsing the error message; it will just return that value.</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span>  <span class="va">as</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/async.html">async</a></span><span class="op">(</span><span class="op">{</span></span>
<span>    <span class="kw"><a href="https://rdrr.io/r/base/conditions.html" class="external-link">tryCatch</a></span><span class="op">(</span></span>
<span>      <span class="fu"><a href="../reference/async.html">await</a></span><span class="op">(</span><span class="fu">with_timeout</span><span class="op">(</span><span class="va">x</span>, <span class="fl">10</span><span class="op">)</span><span class="op">)</span>,</span>
<span>      error<span class="op">=</span><span class="kw"><a href="https://rdrr.io/r/base/function.html" class="external-link">return</a></span><span class="op">(</span><span class="st">"Value was not available"</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="op">}</span><span class="op">)</span></span></code></pre></div>
<p>For that matter, you can provide an error value or handler directly
to <code>await</code>, and this might be more efficient as it doesn’t
have to wind up another tryCatch on the coroutine end of things.</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">as</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/async.html">async</a></span><span class="op">(</span><span class="op">{</span></span>
<span>  <span class="fu"><a href="../reference/async.html">await</a></span><span class="op">(</span><span class="fu">with_timeout</span><span class="op">(</span><span class="fu">promise</span><span class="op">(</span><span class="op">)</span><span class="op">)</span>,</span>
<span>        <span class="st">"Value was not available"</span><span class="op">)</span></span>
<span><span class="op">}</span><span class="op">)</span></span></code></pre></div>
<p>You can also use <code><a href="https://rdrr.io/r/base/Control.html" class="external-link">break</a></code> or <code><a href="https://rdrr.io/r/base/Control.html" class="external-link">next</a></code> or
<code>goto</code> in the <code>error</code> value to take those actions
on error.</p>
</div>
<div class="section level3">
<h3 id="cleaning-up">Cleaning up<a class="anchor" aria-label="anchor" href="#cleaning-up"></a>
</h3>
<div class="section level4">
<h4 id="cleanup-via-on-exit">Cleanup via on.exit<a class="anchor" aria-label="anchor" href="#cleanup-via-on-exit"></a>
</h4>
<p>A coroutine may have a list of exit handlers. The <code>expr</code>
argument to each <code>on.exit</code> is pulled out at parse time to
make each handler; so that their effective scope is outside of any
enclosing loops or tryCatch calls.</p>
<p>At run time, calling <code>on.exit</code>registers the given handler
to be executed later.. When the coroutine finishes, either by normal
return or by error, the coroutine saves the return value and starts
executing each handler that was registered. After the last
<code>on.exit</code> handler has been executed, the saved value is
returned.</p>
<p>A typical use of <code>on.exit</code> might be to close a file or
other resource after you are done reading; here’s a simple generator
that reads a file one line at a time:</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fileLines</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/gen.html">gen</a></span><span class="op">(</span><span class="kw">function</span><span class="op">(</span><span class="va">...</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">f</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/connections.html" class="external-link">file</a></span><span class="op">(</span><span class="va">...</span>, open<span class="op">=</span><span class="st">"rt"</span><span class="op">)</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/on.exit.html" class="external-link">on.exit</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/connections.html" class="external-link">close</a></span><span class="op">(</span><span class="va">f</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="kw">while</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">line</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/readLines.html" class="external-link">readLines</a></span><span class="op">(</span><span class="va">f</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span> <span class="op">&gt;</span> <span class="fl">0</span><span class="op">)</span> <span class="fu"><a href="../reference/gen.html">yield</a></span><span class="op">(</span><span class="va">line</span><span class="op">)</span></span>
<span><span class="op">}</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">as.list</a></span><span class="op">(</span><span class="fu">fileLines</span><span class="op">(</span><span class="st">"language.Rmd"</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 317</span></span></code></pre>
<p>It is possible (but rather strange) to call <code><a href="https://rdrr.io/r/base/stop.html" class="external-link">stop()</a></code> or
<code><a href="https://rdrr.io/r/base/function.html" class="external-link">return()</a></code> from inside an <code>on.exit</code> handler. In
that case the new value and disposition overrides the old one.</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/run.html">run</a></span><span class="op">(</span><span class="op">{</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/on.exit.html" class="external-link">on.exit</a></span><span class="op">(</span><span class="op">{</span><span class="kw"><a href="https://rdrr.io/r/base/function.html" class="external-link">return</a></span><span class="op">(</span><span class="st">"this instead"</span><span class="op">)</span><span class="op">}</span><span class="op">)</span></span>
<span>    <span class="kw"><a href="https://rdrr.io/r/base/stop.html" class="external-link">stop</a></span><span class="op">(</span><span class="st">"an error"</span><span class="op">)</span></span>
<span><span class="op">}</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Error in eval(val, targetEnv): an error</span></span></code></pre>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">x</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] "this instead"</span></span></code></pre>
<p>Here he have an odd situation where an error is printed out to the
console, but the value was returned from <code>run</code> anyway. (Base
R also does this.)</p>
</div>
<div class="section level4">
<h4 id="cleanup-with-tryfinally">Cleanup with try/finally<a class="anchor" aria-label="anchor" href="#cleanup-with-tryfinally"></a>
</h4>
<p><code>tryCatch(expr={...}, finally={...})</code> will execute
<code>expr</code>, and after <code>expr</code> finishes, whether it
finishes normally or not, <code>tryCatch</code> will then execute
<code>finally</code>.</p>
<p>The <code>finally</code> clause will also be executed if you exit
from <code>expr</code> <em>without</em> finishing it, for instance by
<code><a href="https://rdrr.io/r/base/Control.html" class="external-link">break</a></code> or <code><a href="https://rdrr.io/r/base/Control.html" class="external-link">next</a></code> in a loop, or by
<code>goto</code> in a switch statement.</p>
<p>Assuming <code>finally</code> finishes normally,
<code>tryCatch</code> will either return the saved return value or throw
the saved error from <code>expr</code>. If the <code>finally</code>
clause throws an error then the original error will be lost.</p>
</div>
<div class="section level4">
<h4 id="a-caveat-about-cleanup">A caveat about cleanup<a class="anchor" aria-label="anchor" href="#a-caveat-about-cleanup"></a>
</h4>
<p>Writing code in a coroutine’s <code>on.exit</code> clause or in a
<code>tryCatch(finally=)</code> call does not give any guarantee that
the cleanup code will ever run, because coroutines only execute “on
demand.” If you make a generator designed to return ten items, then call
<code>nextOr</code> ten times, the generator will never run its exit
handler. The generator will just be paused waiting to reach end of
iteration; you need to call <code>nextOr</code> an <em>eleventh</em>
time to allow it to reach the end, run ts exit handlers and signal end
of iteration.</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">finished</span> <span class="op">&lt;-</span> <span class="cn">FALSE</span></span>
<span><span class="va">g</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/gen.html">gen</a></span><span class="op">(</span><span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/on.exit.html" class="external-link">on.exit</a></span><span class="op">(</span><span class="va">finished</span> <span class="op">&lt;&lt;-</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span>  <span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">10</span><span class="op">)</span> <span class="fu"><a href="../reference/gen.html">yield</a></span><span class="op">(</span><span class="va">i</span><span class="op">)</span></span>
<span><span class="op">}</span><span class="op">)</span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">j</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">10</span><span class="op">)</span> <span class="fu"><a href="../reference/iteror.html">nextOr</a></span><span class="op">(</span><span class="va">g</span>, <span class="kw">break</span><span class="op">)</span></span>
<span><span class="va">finished</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] FALSE</span></span></code></pre>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/iteror.html">nextOr</a></span><span class="op">(</span><span class="va">g</span>, <span class="st">"stop"</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] "stop"</span></span></code></pre>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">finished</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] TRUE</span></span></code></pre>
<p>Similarly, an <code>async</code> with an <code>on.exit</code> or
<code>finally</code> handler will not exevute those handlers if it is
paused on an <code>await</code> that never resolves. With those caveats
in mind, coroutines do implement both <code>on.exit</code> and
<code>finally</code> constructs and they are useful for sequencing
cleanup actions.</p>
</div>
<div class="section level4">
<h4 id="trycatch-and-iteration-performance">
<code>tryCatch</code> and iteration performance<a class="anchor" aria-label="anchor" href="#trycatch-and-iteration-performance"></a>
</h4>
<p>When a coroutine enters a <code>tryCatch</code> it has to momentarily
save state so that it can wind up an R-level <code>tryCatch</code> on
the stack and then resume. If there is a a <code>yield</code> or
<code>await</code> in the tryCatch expression, the coroutine has to exit
from its tryCatch and re-establish it when execution resumes.</p>
<p>This means that yielding from inside a tryCatch can be more costly,
performance-wise, than a regular yield. This is part of what motivated
the development of the [iteror] class; desiring a protocol for iteration
that did not involve using exceptions for normal flow control.</p>
<p>For instance compare the performance of iterating over an
<code>iterator::iter</code> versus an [iteror].</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">bench</span> <span class="op">&lt;-</span> <span class="fu">microbenchmark</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/microbenchmark/man/microbenchmark.html" class="external-link">microbenchmark</a></span><span class="op">(</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">as.list</a></span><span class="op">(</span><span class="fu"><a href="../reference/gen.html">gen</a></span><span class="op">(</span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fu">iterators</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/iterators/man/iter.html" class="external-link">iter</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">1000</span><span class="op">)</span><span class="op">)</span> <span class="fu"><a href="../reference/gen.html">yield</a></span><span class="op">(</span><span class="va">i</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">as.list</a></span><span class="op">(</span><span class="fu"><a href="../reference/gen.html">gen</a></span><span class="op">(</span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fu"><a href="../reference/iteror.html">iteror</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">1000</span><span class="op">)</span><span class="op">)</span> <span class="fu"><a href="../reference/gen.html">yield</a></span><span class="op">(</span><span class="va">i</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  times<span class="op">=</span><span class="fl">10</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">bench</span><span class="op">)</span><span class="op">[</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"expr"</span>, <span class="st">"median"</span><span class="op">)</span><span class="op">]</span></span></code></pre></div>
<pre><code><span><span class="co">##                                                        expr   median</span></span>
<span><span class="co">## 1 as.list(gen(for (i in iterators::iter(1:1000)) yield(i))) 70.13495</span></span>
<span><span class="co">## 2          as.list(gen(for (i in iteror(1:1000)) yield(i))) 42.21255</span></span></code></pre>
<p>Part of the difference comes from the fact that <code>gen</code> must
use a <code>tryCatch</code> for each time to calls <code>nextElem</code>
on an <code>iterator</code>. Whereas calling <code>nextOr</code> on an
<code>iteror</code> does not involve many calls to
<code>tryCatch</code>.</p>
</div>
</div>
<div class="section level3">
<h3 id="debugging">Debugging<a class="anchor" aria-label="anchor" href="#debugging"></a>
</h3>
<p><code>generators</code> and <code>run</code> try to operate without
using any <code>tryCatch</code> handlers. This means that if a generator
encounters a problem, the error will bubble up through R’s normal error
handling mechanism, and it should be relatively easy to use
<code>options(error=recover)</code> to debug the error.</p>
<p><code>async</code> and <code>stream</code> are required to have a
global <code>tryCatch</code> because any errors they encounter should be
forwarded to listeners. This however makes it a bit harder to debug
them.</p>
<p>The method <code><a href="../reference/debugAsync.html">debugAsync()</a></code> will toggle single step
debugging on a coroutine.</p>
<p>If you call <code>debugAsync(co, R=TRUE)</code> the coroutine
<code>co</code> will start a browser before executing each user-level R
expression. You can press “n” to step through each expression.</p>
<p>If you call <code>debugAsync(co, internal=TRUE)</code> the browser
will be opened at the R implementation level. This will present you with
a twisty little path of tailcalls; Step through each call with
<code>n</code> but make sure to <code>s</code> to step into a tailcall
to follow execution.</p>
<p>The <code>async</code> package imports <a href="https://github.com/crowding/nseval" class="external-link">nseval</a> which can be very
handy at the debugger console. I often use <code>get_function()</code>,
<code>get_call()</code>, and <code>caller()</code> to get a handle on
where exactly the debugger is paused at. <code>arg_env</code>
<code>arg_expr</code>, <code>is_forced</code> and friends really help
when dealing with R’s lazy evaluation,</p>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

      </div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Peter Meilstrup.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

      </footer>
</div>

  


  

  </body>
</html>
