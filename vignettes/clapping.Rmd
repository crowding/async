---
title: "A Musical Introduction to Generators"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{A Musical Introduction to Generators
  %\VignetteEncoding{UTF-8}
---

# A Musical Introduction to Generators

What a generator allows you to do is to take code that is writen in
a sequential, looping style, and then treat that code's output as
a collection to be iterated over.

To illustrate what this means, and the the generators package in
general, I will use R to perform a suitable piece of music,
specifically Steve Reich's "Clapping Music."

The piece is starts with a loop counting out groups of 3, 2, 1, 2, 3,
2, 1, 2, 3... with each group seperated by one rest. This adds up to a
12-note loop:

![Musical score showing loop](clapping_music.svg)

In code, we could implement that idea like the following, printing a
`1` for each clap and a `0` for each rest:

```{R}
print_pattern <- function(counts = c(3, 2, 1, 2), repeats=4) {
  for (i in seq_len(repeats)) {
    for (c in counts) {
        for (j in 1:c)
          cat(1)
        cat(0)
    }
}
```

Testing this, we should see groups of 1, 2, or 3 `1`s separated by a single  `0`:
```{R}
print_pattern(repeats=4); cat("\n")
```

"Clapping Music" is based on manipulating this 12-count loop. But it's hard to
manipulate the output of a program that just prints. The calls
to `cat` produce output on the terminal, but they don't produce data
that we can easily manipulate with more programming -- we need to make
this pattern into data, rather than terminal output.

One way to proceed might be would be to rewrite `pattern` so that it
allocates an output vector, whose size would be calculated in advance,
then place each note into the appropriate place in the output. There
would need to be another index variable to track the output index,
since the output index corresponds to neither `c` nor `j`.

by using a generator. To do this, enclose the body of the function in
a call to `gen()`, and change each `cat()` to `yield()`.

```{R}
gen_pattern <- function(counts = c(3, 2, 1, 2)) { force(counts)
  async::gen({
    repeat {
      for (n in counts) {
        for (j in 1:n)
          yield(1)
        yield(0)
      }
    }
  })
}
```

Mostly the differences are: the function body is wrapped in `gen(...)`
and changed `cat` to a `yield`. Adding `force(counts)` is a good idea
because of lazy evaluation; otherwise`counts` will not have a fixed
value before `gen_pattern()` returns. And the `repeat` argument is
gone and the outer `for` is changed to a plain `repeat`, because a
generator produces data on demand.

The code inside `gen(...)` does not run, yet. The call to `gen`
constructs an
[iterator]([iterator](https://cran.r-project.org/web/packages/iterators/index.html)),
which supports the method `nextElem`. When `nextElem()` is called on a
generator, the generator runs its code only up to the point where
`yield` is called. The generator returns this value, and pauses
state until the next call to `nextElem()`.

```{R}
p <- gen_pattern()
cat(nextElem(p), "\n")
cat(nextElem(p), "\n")
cat(nextElem(p), "\n")
cat(nextElem(p), "\n")
for (i in 1:23) { cat(nextElem(p)) }; cat("\n")
```
`gen(...)` constructs and returns an
[iterator](https://cran.r-project.org/web/packages/iterators/index.html),
which means you can apply iterator methods to it. Here's a tool to
print the first 24 items yielded:

```{R}
show_head <- function(x, n=24) {
  x |> itertools::ilimit(n) |> as.list() |> deparse() |> cat(sep="\n")
}
show_head(gen_pattern(), 24)
```

## Making noise

We're a good way into what I advertised as a musical endeavour and
haven't made any sounds yet. First let's download some handclap
samples. I located some on GitHub:

```{R, eval=FALSE}
tmp <- tempdir()
baseurl <- "https://github.com/octoblu/drum-kit/raw/master/public/assets/samples"
samplepaths <- paste0(tmp, c("x" = "/clap4.wav","X" = "/clap5.wav"))
curl::curl_download(paste0(baseurl, "/clap%20(4).WAV"), samplepaths[1])
curl::curl_download(paste0(baseurl, "/clap%20(5).WAV"), samplepaths[2])
```

Although R is not known for audio performance, there is an `audio`
package playing sound samples.

```{R, eval=FALSE}
library(audio)
samples <- lapply(samplepaths, audio::load.wave)
audio::play(samples[[1]])
audio::play(samples[[2]])
```

Now let's try adding sound. This generator function `with_sound` plays the
appropriate sample every time a value goes through.

```{R}
with_sound <- function(g, samples) { list(g, samples)
  async::gen({
    for (x in g) {
      if(is.numeric(x) && x >= 1 && x <= length(samples)) {
        cat(x)
        audio::play(samples[[x]])
      } else {
        cat(".")
      }
      yield(x)
    }
    cat("\n")
  })
}
```

So we should hear two sounds here:

```{R}
g <- async::gen({yield(1); yield(2)}) %>% with_sound(samples)
invisible(nextElem(g))
invisible(nextElem(g))
```

We need to do this at a consistent tempo, so here's a routine that takes in a
generator and a sample list, and then

```r
play <- function(g, bpm, samples) {
  interval <- 60 / bpm
  target <- Sys.time()
  repeat {
    tryCatch({
      x <- nextElem(g), error=`break`
    })
    target <- target + interval
    while({now <- Sys.time(); Sys.time() > 0.15}) Sys.sleep(target - now - 0.15)
    profvis::pause(target - Sys.time())
    if(is.numeric(x) && x >= 1 && x <= length(samples)) {
      cat(x)
      audio::play(samples[[x]])
    } else {
      cat(".")
    }
  }
}
```


Here's a couple of utility functions we'll need for the next bit. One
is an equivalent of `lapply` for iterators, which I'll call
`iter_map`. The other one is `sink` which just consumes all elements
from an iterator.

```r
iter_map <- function(it, f, ...) {  list(it, f, ...)
  async::gen(for (x in it) yield(f(x, ...)))
}
sink <- function(x) {
  tryCatch(repeat last <- nextElem(x),
           error=function(e)
             if (!identical(conditionMessage(e), 'StopIteration')) stop(e))
  invisible(last)
}
```

Back to making sounds.  If we let the generators run at fast as they
could, the sound played wouldn't be intelligible. We need to set a
tempo. So here is a generator function which passes its input to its
output at a specified rate.

```r
with_tempo <- function(g, bpm) {  list(g, bpm) #force
  interval <- 60 / bpm
  async::gen({
    target <- Sys.time()
    for (i in g) {
      yield(i)
      target <- target + interval
      now <- Sys.time()
      if (target - now > 0.15) Sys.sleep(target - now - 0.15)
      profvis::pause(target - Sys.time()) #for better precision
    }
  })
}
```

So this should print numbers at a regular interval:

```r
iter(1:20) %>% with_tempo(180) %>% iter_map(cat) %>% sink
```

Now we are ready to hear the rhythm, by pipelining our
pattern through our noisemaker and metronome.

```r
gen_pattern() %>% with_sound(samplepaths) %>% with_tempo(320) %>%
  itertools::ilimit(48) %>% sink
```

> **Side note / caution:** By now you might have noticed I've been placing
> "force" and "list" in the first line of functions that return
> generators.  This is actually something you should do any time you
> construct and return an inner function, iterator, promise, or other
> construct that captures your arguments for future reference. The issue
> is the basic R issue, where lazy evaluation + mutable bindings allows
> a function's inputs to change after it has been called -- for example,
> `%>%` will call a pipeline function with the argument `.`, but after
> it returns, `%>%` will change the binding for `.` A `for` loop
> will similarly clobber the binding of its iterator variable.

---

## Phasing and combining

"Clapping Music" is a piece for two performers, who both play the same
pattern, but after every 12 loops, one of the performers skips forward
by one step, so that over the course of the piece, the two parts move
out and in phase with each other. A generator function models the
occasional skip nicely, by consuming a value without yielding it:

```r
drop_one_after <- function(g, n, sep) {  list(g, n)
  if (missing(sep)) sep <- ""
  async::gen(
    repeat {
      for (i in 1:n) yield(nextElem(g))
      iterators::nextElem(g) #drop
      cat(sep)
    }
  )
}
```
Here, illustrated with a count that skips one after emitting three -- that is,
dropping every fourth item (and printing a newline.)

```r
iterators::icount() %>% itertools::ilimit(12) %>% drop_one_after(3, "\n") %>%
  iter_map(cat, "") %>% sink
```

Now, we can make two generators, have one of them skip some beats, and
add them together:

```r
clapping_music <- function(n=12, counts=c(3,2,1,2), sep=" ") {
  cell <- sum(counts+1)
  a <- gen_pattern(counts)
  b <- gen_pattern(counts) %>% drop_one_after(n*cell, sep)
  # add them together and limit the output
  async::gen(for (i in 1:n*(n+1)*cell) {
    yield(nextElem(a) + nextElem(b))
  })
}
```

To narrate this: we are constructing two independent instances of our
basic 12-beat `XXX.XX.X.XX.` pattern. One of these patterns is made to
skip one beat every N bars. create a third generator that adds
together the two.

```r
clapping_music(4, "\n") %>% iter_map(cat) %>% sink
```

## A performance

Now all that's needed is to pipe this through a noisemaker.

```r
clapping_music(12) %>%
  with_tempo(320) %>%
  with_sound(samplepaths) %>%
  sink
```

R is definitely not a multimedia environment, plus the `audio` package
is using the OS alert sound facility, which is not designed for
precise timing, so I can hear some glitches and pauses on
occasion. However this does illustrate some of the things you can do
with generators; how he generators package allows control to be
_interleaved_ among different sequential processes.


---

# Appendix: alternate implementations of `pattern`

[appendix]: I mentioned above that implementing `pattern` to output a vector
involves extra calculations and maintenance of index variables. Here's the
example, with `gen_pattern` repeated for comparison.

```{R}
gen_pattern <- function(counts = c(3, 2, 1, 2)) { force(counts)
  generators::gen({
    for (n in itertools::recycle(counts)) {
      for (j in 1:n)
        yield(1)
      yield(0)
    }
  })
}

vec_pattern <- function(counts = c(3,2,1,2)) {
  out <- vector(mode="numeric", length=sum(counts) + length(counts))
  ix = 1
  for (c in counts) {
    out[ix:(ix+c-1)] <- 1
    ix <- ix + c + 1
  }
  out
}
```

On the other hand, here's what `gen_pattern` would look like if you
directly implemented it as an iterator.  It requires some state
variables that `nextElem` closes over, as well as some work to check
and update those variables using `<<-`.

```{R}
iter_pattern <- function(counts=c(3,2,1,2)) {
  counts <- itertools::recycle(iter(counts))
  c <- 0
  gi <- 1
  itertools::new_iterator(function() {
    c <- nextElem(counts)
    if (gi <= c) {
      gi <<- gi + 1
      return(1)
    } else {
      ci <<- ci + 1
      gi <- 1
      return(0)
    }
  })
}
```

This is because we can't use `for`, `if`, and such to directly track
state; because an iterator always has to return from nextElem. it has
to maintain its state by hand. This is unfortunate because, as the
designers of ALGOL originally found in their research, constructs like
`if`, `repeat`, `while`, `for`, `switch`, are very useful for
describing common patterns in state machines! Another way to think
about what the `generators` packageis doing is implementing a
domain-specific language for iterators -- where the DSL is built to
act a lot like the host language.
