
# ESS versus closxps?!

Apparently the reason I can't just tag a "class" attribute onto a closxp and call that an iteror is.... ESS is fucking with me. If I evaluate a chunk in ESS, it is altering the environment of the resulting closxp. it comes back with the enclosing environment set to the package namespace, instead of the environment that _really_ enclosed it and has its variables. It's weird.


## Emacs locking up when I pause in R debugger

Aargh, something is happening in ess-mode that makes emacs lock up waiting for a response when it's in the debugger. Can be triggered by ess-whatever-completions mode. Is triggered by just having point in an R buffer for a few seconds.

ESS output window keeps saying "Disabling output delimiter because CMD failed to parse."

This is likely because all my variable names in the compiled generators are fucky.

## it would be nice if name-munging twice were idempotent.

(i.e. ended up with the names and translated functions.) One way to do
that might be to not bother slapping context on the names of nodes in
the special "first" context encountered.)

## Debugging tools

Make some methods that allow single stepping the R code, as well as to allow single stepping the "interior" code.

Setting "debugOnce" on pumpCont (whenever it's updated) would do it.

And an option for user-level stepping, evaluating "browser()" in the
target environment and single stepping.

Meanwhile, it might be good to do R's "eval" via a handler, so as to condense references to the target environment.

## display of handlers in graphs

make a custom node style for handlers, or maybe an out-and-back edge?
An edge to a node in the middle of a trampoline edge might work too.
Hey maybe rewrite drawGraph() in collector style?

## move eval_ to a handler

The problem I'm trying to solve is that there are a bunch of duplicate references to the target environment captured in the graph. If I'm going to be able to reuse a compiled generator, that should just be one ref to the target environment; it's currently being duplicated all around with

## on.exit

I suppose I'm on a roll so I think Ii'll add this. on.exit handlers will be global to the generator they're running in. Conceptually they will be operating _outside_ of any loop, even if written within, Therefore at construction time, they are passed back to the top-level pump(), using a `register_exit` callback, in return for a handle. At run time, the `on.exit` CPS function calls a callback `add_exit` with that handle to activate the handler (which appends the handle to a list). At the pump level, the on-exit handler will behave like a switch statement looping over the list and calling until it is exhausted.

At the pump level, pump `return_` should jump to do_exits before continuing to exit.

You can put a check for doneness into an on-exit clause in pump(). If it exits without pausing, enter a special state, bounce to the on-exit handler and pump() again.

I think I will work on getting that mechanic right first, then worry about switch-case alignment later. Make it work for the interpreted case before trying to add the bquote shenanigans to make the compiler pick it up.

## yieldFrom under "run" winds up the stack

Have to stick a bounce back in there. That means a generator has two bounces per loop instead of 1 hmm. Or else we have to bounce on yieldFrom's yield. That might make more sense.

## Where does on.exit get its yield callback?

Should it have one? I don't see why not. but the yield callback for a generator comes form gen_cps which is "under" pump. Which means that if pump constructs the on.exit handlers they can't see the yield.

Is there a reason I structured it this way? because we have to yield the value AND pause the generator. but I can pass the pointer to "pause" to a yield callback. That's a another damn double callback like windup though.

Why doesn't async run into this problem?

Okay, the most reasonable course of action is to pass our yield callback into pump and stop wrapping. We still have to

This has resulted in seeing "pump" as a utility call?

One side effect of this is now we are seeing "pump" as a utility call in nextElemOr?
 
 on.exit is leaking scope! I wind up back in doExits. Which call is leaking? Oh duh of course the `exit_fns` list is leaking. Well now on/exit works in compiled, but `expect_properly_munged` fails because graph walk is picking up a "gen_f_pump" for some reason.
 
 See, even if it's called as a utility function the ref should translate, no?
 
## trans_ needs to translate function defaults?

Or I need to just not write them.

So why is the call to pump() not being translated to the right function _pump_?
That's in _trans_, right?
