## Fixing "switch"

The current CPS version does not do branch fallthrough. To fix that I
would need to know during construction which arguments are missing.

R native "switch" does a thing where it can end up executing no arguments.

    switch(-1, "one", "two", "three") #takes no branch and returns NULL.

That behavior would be bad to use base R switch as a compiled version of switch, because it would end up falling off and not tailcalling.

Let's see, what about if you initialize a "mapping" at run time and then switch based on a label you pull out of there?

The other problem with switch is that

# making arguments "quotable"

Some constructors might want to get the "quoted" arguments of stuff they aren't going to evaluate. Like "switch", or "for" for that matter.

# ESS versus closxps?!

Apparently the reason I can't just tag a "class" attribute onto a closxp and call that an iteror is.... ESS is fucking with me. If I evaluate a chunk in ESS, it is altering the environment of the resulting closxp. it comes back with the enclosing environment set to the package namespace, instead of the environment that _really_ enclosed it and has its variables. It's weird.

# Name munging

### duplication of trace() and such

Okay, I apparently left off in the midst of munging names. Judging from where I left the `browser()` call, I was finding an argument that transfers "state variables" except that these variables are never updated. If they are never updated then I should be able to dedupe them. But not deduping them will not prevent me from reaching proof of concept with compilation. Deduping of unused variables is a future problem.

However, the other problem with porting over utility variables is what variables are they closed over with? So one resolution might be to treat local functions found in non tail position as a kind of node, and thus capture the variables it itself refers to? Hopefully this doesn't lead to infinite regress? This would be at graph enumeration time.

### Switch in graphs
I need to do something tricky to make my implementation of `switch` traversable by `walk`. Like bquote() out a custom switch_cps. See [switch.R]().

### Speed of walking the graph.

There did appear to be some O(N^2) rearing their heads when walk()ing a graph. Run a profiler? There are definitely some O(n^2) data structures currently in there.

I did something to make myself use hashbags more consistently and noticed a speedup! So there was def some list reallocation going on.

Interestingly, using a list by index isn't much slower than using an env until you get past 100 elements or so. (see ) But s3 dispatch and going through `hashbag()` is quite a bit slower. See [map_timings.Rmd](). So I might want to just use lists instead of hashbags. If I can keep them from having to copy themselves all the time.

### Munging names

So I've gathered all the nodes, or so I claim. I am trying to get a sense of what other things are referenced in each of these nodes.

### Munging state pointers

"state pointers" i.e. closed-over values that contain references to nodes in the graph. These need to be updated.


```{R}

pretty <- function(thing) {
  cat(deparse(unclass(as.list(thing)), width.cutoff = 60), sep="\n")
}

```


One example of a read-only function value is "nonce", "value", "pumpCont", "err" which is in context `_stop` (which actually looks like it should be called `pump` as part of the start set...). I think I am just going to carry that value over literally -- this may result in having the same nonce across several instances of a generator but I think that will be okay. A nonce is never actually called, though.

Hold on, though. I should be picking up that these values are changed, or else why are they initialized to nonce? It thinks `pump$err`, initialized to a nonce, is not a state variable. Why? Because this particular generator _does not reach stop_. Oh! That means it can drop out during inlining.


### doWindup is not copied over

```
> nextElemOr(gc)
Error in doWindup(runPump, ...) (from iteror.R#84) : could not find function "doWindup"
```

On inspecting graph, I find that doWindup is listed as a "call" but not as a "utility"

Now I'm in a process of trying to invoke nextElemOr and seeing what breaks next.

`doWindup` should be translated as a node, though, no? It should be in the start set.
Next we have "assert". I removed the call to assert in pump.r.

### What else stops these from running....

Now I have some problems debugging because all the are happening within runPump's tryCatch thingy.

Now we have "verbose": this line is failing:

```
if (`stop_|verbose`) `stop_|trace`("pump: set unpause\n")
<simpleError in cont(...): object 'stop_|stop' not found>
```

These are failing some

### does generator need to catch?

I know I need to fix the next things. It has been pretty difficult with the big tryCatch wrapped around everything, to get a stack trace. Do we even need a tryCatch around nextElemOr? I turned off the "base winding" for generators (but not for asyncs), and no tests failed. Nwo my stack traces are a bit healthier.

## Emacs locking up when I pause in R debugger

Aargh, something is happening in ess-mode that makes emacs lock up waiting for a response when it's in the debugger. Can be triggered by ess-whatever-completions mode. Is triggered by just having point in an R buffer for a few seconds.

ESS output window keeps saying "Disabling output delimiter because CMD failed to parse."

## it would be nice if name-munging twice were idempotent.

(i.e. ended up with the names and translated functions.) One way to do
that might be to not bother slapping context on the names of nodes in
the special "first" context encountered.)

## tryCatch failing in munged asyncs/generators

I'm interested to note that `base_winding` is not translated; It's kept in a list. Should it be? As well as other utility functions defined locally?

## Not all nodes in a compiled async find local names.

Again it is leaking nodes, pulling in a node that should have been translated to its new environment?

That definitely shouldn't happen. But if I draw a picture of the graph it might tell me where the leak is!

But even before that the graph tells me it's before compilation that things don't have local names.
So it looks like "then" is not getting a local name? But it has one???

Lots of things are not getting a local name even when compilation is off.

It seems like I'm putting a value into the hashbag but then it's not getting out???
This was a dumb error.

Next the problem I have is the state pointers are not closed. In particular, resolve and reject, which are non-closed pointers by design. But they should not be counted as state pointers because I don't tailcall into them?

Munge calls them a: "State var with unknown function value(?)" I think that's correct. 

I shouldn't care about these variables being closed. Only stuff that is tailcalled?

## Perform a check for well-formedness of generator on all generators during unit test.

I turned "paranoid" on for tests at compile level -1. It checks that everything really got moved over!. I turned up ONE problem in async.

## Refactor so that trampoline handlers do not use `...` but either take a value or not..

Okay, this `...` business in the handlers might be getting silly. I think for sanity's sake I might have to declare some trampolines take a `val` and others don't. That will be another refactoring (probably before I do codegen)

## Awaiting on a "pr" that doesn't exist gives a "subscript out of bounds"

In this:

      async({
        tryCatch({
          if (await(pr)) {
            return(5)
            not_run <<- FALSE
            5
          } else 4
        }, finally={
          cleanup <<- TRUE
        })
      }

It _should_ give a more comprehensible error. This particular error sounds like something wrong.

## Walking compiled try/finally

fails to walk() a compiled async containing try/finally upon finding a call to finally's `cont` that wasn't translated. It's counted as a tailcall in the compiled graph;.

Sure enough it's not picked up as an edge....

Let's look at the graph uncompiled. It's node "_do_expr.1.awaited.then.1.ifTrue.1.do_finally.1". It's got "cont" in the tail, sure enough. It's not translated why?  because `walk` didn't see the `cont` call for some reason. Except it does.

branch name `cont` points to "_do_expr.1.awaited.then.1.ifTrue.1.do_finally.2", so it's not translated??? So let's see what munge does with this node.

Sure enough "nms" does not contain "cont". Oh Problem was I forgot to change a reference of edgeProperties$label to localName. I'm just confused how the fuck anything worked like that. (how the fuck did anything work that way?)

It sure would be nice if I had strong typing to check that I was using
the same field name that it was created with.

Nope, that didn't help it catch "cont." The edge to "cont" didn't make it into the graph edgeproperties?

Let's turn on verbose for walk again.

OHHHHHHH it's because both targets exit to the same node. In particular, both "cont" and "return" went to the same place.

So I need to index edges by their local name(!) rather than their global name. Or else consolidate the local names. The former requires a bigger refactoring. The local names are unique and each _does_ make for a distinct edge. 

But the latter seems trickier.

Before I tackle this, make sure my graph isomorphism check works. I mean I'll have to rewrite it too. But rewriting from a good starting point should work.

How about the rewrite comes with a change of name from "edgeProperties" to "nodeEdges"

# better context/node labels

Would be easier to understand if context / node labels were
